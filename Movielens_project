---
#This project is submitted with the purpose to gain a score as per the EDX module 
Title: "MovieLens Project: Data Science - HarvardX"
Author: "Mitta"
Date: "09 Oct 2019"
Required Time: About an hour
Output: 
  pdf_document: default
  html_document: default
  
  ---
  
# **Introduction**
This is a project recommended on the Data Science course, 
in which we are required to provide some movie recommendations
based on the data selected for the purpose of this course: MovieLens data 10M [the M represents million ratings which are available on the set].
Additionally, the goal of the project is to estimate the ratings that users would likely give.
Also to note, the number of users is 72,000. We must also calculate the RMSE. Ideally, RMSE <0.87750.

##The user is expected to have the R programme downloaded already.
##If not, download it for Windows from: 
##https://cran.r-project.org/bin/windows/base/.
##Use the 64-bit to maximise on memory space.


# **Stage 1: Begin setting up for your analysis**

##Load your data libraries
##Using the code from the course

{r}

################################
# Create edx set, validation set
################################

# Note: this process could take a couple of minutes

if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")

# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip

dl <- tempfile()
download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")
movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(levels(movieId))[movieId],
                                           title = as.character(title),
                                           genres = as.character(genres))

movielens <- left_join(ratings, movies, by = "movieId")

# Validation set will be 10% of MovieLens data

set.seed(1, sample.kind="Rounding")
# if using R 3.5 or earlier, use `set.seed(1)` instead
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]

# Make sure userId and movieId in validation set are also in edx set

validation <- temp %>% 
     semi_join(edx, by = "movieId") %>%
     semi_join(edx, by = "userId")

# Add rows removed from validation set back into edx set

removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)


#################################################
# **Stage 2: Data Analysis**
################################################
We will now be analysing the data

# Check the data

{r}
glimpse(edx)

# Analyse the ratings

{r ratings_table}
edx %>% group_by(rating) %>% summarize(count = n())%>% 
  rename ("Rating Given" = rating) %>%
  rename (Count = count) %>%
  kable()
  
# What is the number of ratings?

r {nrow(edx)}

# What is the min and max number of years in which ratings take place?

r {format(as_datetime(min(edx$timestamp)))}
r {format(as_datetime(max(edx$timestamp)))}

# Calculate the number of users who are not standard
 
 r n_distinct(edx$userId)
  
# Calculate the number of nonstandard movies in the dataset
  
  r n_distinct(edx$movieId)
  
# Which movies are mostly rated?

{r movies_distribution, fig.align='center'}
edx %>%
count(movieId) %>%
ggplot(aes(n)) +
geom_histogram(bins = 30, color = "black") +
scale_x_log10() +
xlab("Number of ratings") +
  ylab("Movies Count") +
ggtitle("Number of ratings per movie") + theme(plot.title = element_text(hjust = 0.5))

# Which genres are likely to be popular?

{r genre_distribution}
edx %>% rename(Title = title) %>% group_by(Title) %>%
   summarize(count = n()) %>%
   arrange(desc(count)) %>% 
   top_n(10) %>%
   rename("Ratings Count" = count) %>%
    knitr::kable()
    
 
 # How many ratings are given in a year?
 
 {r}
edxRatingsGivenPerYear <- edx %>%
    mutate(tsYear = year(as_datetime(timestamp))) %>%
    group_by(tsYear) %>%
    summarize(nRatings = n(), differentUsers = n_distinct(userId), differentMovies = n_distinct(movieId))

# What are the top 3 rated movies?
top3 <- edx %>% group_by(movieId) %>% summarize(count = n()) %>% 
  arrange(desc(count)) %>% head(3)

top3


# **Perform a visualisation of the top 3 ratings**

top_movies %>% #For top 3 rated movies
  ggplot(aes(x=reorder(title, count), y=count)) +
  geom_bar(stat='identity', fill="dark green") + coord_flip(y=c(0, 50000)) +
  labs(x="", y="Number of ratings") +
  geom_text(aes(label= count), hjust=-0.1, size=3) +
  labs(title="Top 3 movies based \n on number of user ratings" , 
       caption = "source data: edx data table")
       
# Which movies have the most ratings of all time?

{r Rating Frequency, echo=FALSE, message=FALSE, warning=FALSE}
edx %>% group_by(title) %>% summarise(n = n()) %>% arrange(desc(n)) %>% top_n(5) %>% niceKable


########################################################################
# **Stage 3: Calculating the RMSE**
########################################################################

RMSE <- function(true_ratings, predicted_ratings){
  sqrt(mean((true_ratings - predicted_ratings)^2))
}

   # Predict the RMSE on the validation set
   
   return(RMSE(validation$rating, predicted_ratings))
})
# plot the result of lambdas
df <- data.frame(RMSE = rmses, lambdas = lambdas)
ggplot(df, aes(lambdas, rmses)) +
   theme_classic()  +
   geom_point() +
   labs(title = "RMSEs vs Lambdas - Regularized Movie+User Model",
        y = "RMSEs",
        x = "lambdas")
# Get the lambda value that minimize the RMSE
min_lambda <- lambdas[which.min(rmses)]
# Predict the RMSE on the validation set
rmse_regularized_movie_user_model <- min(rmses)
# Adding the results to the results dataset
results <- results %>% add_row(model="Regularized Movie+User Based Model", RMSE=rmse_regularized_movie_user_model)
```

The RMSE on the ```validation``` dataset is **0.8629**. The Regularized Movie+User Based Model improves just a little the result of the Non-Regularized Model.

### Regularized Movie+User+Genre Model

```{r}
# Calculate the average of all movies
mu_hat <- mean(edx$rating)
# Define a table of lambdas
lambdas <- seq(0, 15, 0.1)
# Compute the predicted ratings on validation dataset using different values of lambda
rmses <- sapply(lambdas, function(lambda) {
   # Calculate the average by user
   
   b_i <- edx %>%
      group_by(movieId) %>%
      summarize(b_i = sum(rating - mu_hat) / (n() + lambda))
   
   # Calculate the average by user
   
   b_u <- edx %>%
      left_join(b_i, by='movieId') %>%
      group_by(userId) %>%
      summarize(b_u = sum(rating - b_i - mu_hat) / (n() + lambda))
   
    b_u_g <- edx %>%
      left_join(b_i, by='movieId') %>%
      left_join(b_u, by='userId') %>%
      group_by(genre) %>%
      summarize(b_u_g = sum(rating - b_i - mu_hat - b_u) / (n() + lambda))
   
   # Compute the predicted ratings on validation dataset
   
   predicted_ratings <- validation %>%
      left_join(b_i, by='movieId') %>%
      left_join(b_u, by='userId') %>%
      left_join(b_u_g, by='genre') %>%
      mutate(pred = mu_hat + b_i + b_u + b_u_g) %>%
      pull(pred)
   
   # Predict the RMSE on the validation set
   
   return(RMSE(validation$rating, predicted_ratings))
})
# plot the result of lambdas
df <- data.frame(RMSE = rmses, lambdas = lambdas)
ggplot(df, aes(lambdas, rmses)) +
   theme_classic()  +
   geom_point() +
   labs(title = "RMSEs vs Lambdas - Regularized Movie+User+Genre Model",
        y = "RMSEs",
        x = "lambdas")
# Get the lambda value that minimize the RMSE
min_lambda <- lambdas[which.min(rmses)]
# Predict the RMSE on the validation set
rmse_regularized_movie_user_genre_model <- min(rmses)
# Adding the results to the results dataset
results <- results %>% add_row(model="Regularized Movie+User+Genre Based Model", RMSE=rmse_regularized_movie_user_genre_model)
```

The RMSE on the ```validation``` dataset is **0.8628** and this is the best result of the builted models. The Regularized Movie+User+Genre Based Model improves just a little the result of the Non-Regularized Model. As the Non-Regularized Model, the ```genre``` predictor doesn't improve significantly the model's performance.

# Results and conclusion

This is the summary results for all the model builted, trained on ```edx``` dataset and validated on the ```validation``` dataset.

```{r}
# Shows the results
results %>% 
   kable() %>%
   kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
             position = "center",
             font_size = 10,
             full_width = FALSE)
             
          
             
             
             



